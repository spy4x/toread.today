import { readFileSync, unlinkSync } from 'fs';
import * as XRegExp from 'xregexp';
import { every, map } from 'async-parallel';
import { Item, ItemPriority, ItemSkeleton, Tag } from '../../+utils/interfaces';
import { createNotification, isUrl } from '../../+utils/common';
import { runTransaction } from '../../+utils/firebase/runTransaction';
import { bucket, createId, firestore } from '../../+utils/firebase/firebase';
import { getTriggerStorageOnFileUpload, StorageFile } from '../+utils/trigger';


/**
 * Creates missing tags
 * @param tagIdOrTitle tag id and new tag title. New tag will be created from tag title.
 * @param userId
 * @param cache Map of <tagIdOrTitle, tagId> to avoid massive calls to DB
 * @returns array of tags ids
 */
const getTagIdOrCreate = async (tagIdOrTitle: string, userId: string, cache: Map<string, string>): Promise<string> => {
  let tagId = cache.get(tagIdOrTitle);
  if (tagId) {
    return tagId;
  }

  tagId = await runTransaction<string>(async transaction => {
    if (tagIdOrTitle.length === 20) { // length of Firestore document autogenerated ID
      const doc = await transaction.get(firestore.doc(`tags/${tagIdOrTitle}`));
      if (doc.exists && doc.data().createdBy === userId) {
        return doc.id;
      }
    }

    const query = firestore
      .collection(`tags`)
      .where('title', '==', tagIdOrTitle)
      .where('createdBy', '==', userId)
      .limit(1);
    const snapshot = await transaction.get(query);
    if (!snapshot.empty) {
      return snapshot.docs[0].id;
    }

    // TODO: replace with factory function or service
    const newTag: Tag = {
      title: tagIdOrTitle,
      color: '#209cee',
      mergeIntoTagId: null,
      createdBy: userId,
      createdAt: new Date()
    };
    const id = createId();
    transaction.create(firestore.doc(`tags/${id}`), newTag);
    return id;
  }, { logPrefix: 'getTagIdOrCreate' });
  cache.set(tagIdOrTitle, tagId);
  return tagId;
};


const idRegex = `[\\w-]+`;
/**
 * Regex for string like "users/USER_ID/imports/FILE_ID"
 */
export const storageHandlerRegexpImportFile = `
users\/(?<userId>${idRegex})\/    # users/USER_ID/
imports\/(?<fileId>${idRegex})$   # imports/FILE_ID`;
const regex = XRegExp(storageHandlerRegexpImportFile, 'x'); // x = free-spacing, newlines and line comments
const CONCURENT_URL_HANDLERS_POOL_SIZE = 1;

const deleteFiles = async (localPathToFile: string, file: StorageFile): Promise<void> => {
  console.log('Removing files');
  if (localPathToFile) {
    unlinkSync(localPathToFile); // remove file from `/tmp/` to save memory for future functions
  }
  await bucket.file(file.path).delete(); // remove file in storage
  console.log('Files were removed');
};

export const stFileUpload = getTriggerStorageOnFileUpload({
  handler: async file => {
    console.log('Path:', file.path);
    let localPathToFile: string;
    const statistics = {
      total: 0,
      added: 0,
      ignored: 0,
      notValid: 0
    };
    const tagsCache = new Map<string, string>();
    console.log('File:', file);
    const variables = XRegExp.exec(file.path, regex);
    if (!variables) {
      console.error('No variables =/');
      return;
    }
    const { userId, fileId } = variables;
    console.log('Params:', { userId, fileId });
    try {
      localPathToFile = `/tmp/${fileId}`;
      await bucket.file(file.path).download({ destination: localPathToFile });
      console.log('File downloaded successfully');

      const fileBuffer = readFileSync(localPathToFile);
      const bulk: { items: ItemSkeleton[], tags: string[], priority: ItemPriority } = JSON.parse(fileBuffer.toString());
      console.log('File has been read successfully',
        { items: bulk.items.length, tags: bulk.tags.length, priority: bulk.priority });

      await createNotification({ text: `Parsing file with ${bulk.items.length} items`, userId });

      // TODO: Do I need to check URL for uniqueness before add? Won't it be faster to add it and check later async?
      // TODO: Do I still need 'async-parallel' library if this operation is sequential?
      await every(bulk.items, async (itemSkeleton: ItemSkeleton, index: number) => {
        if (index && index % 100 === 0) {
          await createNotification({ text: `${index} lines of ${bulk.items.length} parsed`, userId });
        }
        statistics.total++;
        if (!isUrl(itemSkeleton.url)) {
          statistics.notValid++;
          return true;
        }
        // Check URL for uniqueness and save to DB if it is
        await runTransaction(async transaction => {
          const query = firestore
            .collection(`items`)
            .where('url', '==', itemSkeleton.url)
            .where('createdBy', '==', userId)
            .limit(1);
          const snapshot = await transaction.get(query);
          if (!snapshot.empty) {
            statistics.ignored++;
            return true;
          }
          const tagsMix = [...bulk.tags, ...itemSkeleton.tags];
          const tagsIds = await map<string, string>(tagsMix, value => getTagIdOrCreate(value, userId, tagsCache), 1);

          // TODO: create item object with a factory function
          const newItem: Item = {
            ...itemSkeleton,
            tags: tagsIds,
            type: null,
            status: 'new',
            priority: bulk.priority,
            rating: 0,
            comment: '',
            withComment: false,
            isFavourite: false,
            createdBy: userId,
            createdAt: new Date(),
            openedAt: null,
            finishedAt: null,
            urlParseError: null,
            urlParseStatus: 'notStarted'
          };

          transaction.create(firestore.collection(`items`).doc(createId()), newItem);
          statistics.added++;
          return true;
        }, { logPrefix: 'Check URL for uniqueness and save to DB if it is' });
        return true;
      }, CONCURENT_URL_HANDLERS_POOL_SIZE);
      console.log('URLs creation is finished. Statistics:', statistics);

      await deleteFiles(localPathToFile, file);

      let message = 'File parsed. URLs: ';
      if (statistics.added) {
        message += `${statistics.added} created. `;
      }
      if (statistics.ignored) {
        message += `${statistics.ignored} ignored. `;
      }
      if (statistics.notValid) {
        message += `${statistics.notValid} not valid. `;
      }
      await createNotification({ text: message, userId });
    } catch (error) {
      console.error('fileUpload', error);
      await deleteFiles(localPathToFile, file);
      await createNotification({ text: 'Parsing failed. Try again or notify developer', userId });
    }
  }
});
